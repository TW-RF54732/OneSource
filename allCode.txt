onesource/
├── Cargo.lock
├── Cargo.toml
└── src/
    ├── aa/
    ├── examples/
    │   └── filter.rs
    ├── filter_utils.rs
    ├── io_utils.rs
    ├── main.rs
    └── tree_utils.rs
<file path="Cargo.lock">
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddd31a130427c27518df266943a5308ed92d4b226cc639f5a8f1002816174301"
dependencies = [
 "memchr",
]

[[package]]
name = "anstream"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
dependencies = [
 "windows-sys",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys",
]

[[package]]
name = "bstr"
version = "1.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63044e1ae8e69f3b5a92c736ca6269b8d12fa7efe39bf34ddb06d102cf0e2cab"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "clap"
version = "4.5.54"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c6e6ff9dcd79cff5cd969a17a545d79e84ab086e444102a591e288a8aa3ce394"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.54"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa42cf4d2b7a41bc8f663a7cab4031ebafa1bf3875705bfaf8466dc60ab52c00"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.49"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a0b5487afeab2deb2ff4e03a807ad1a03ac532ff5a2cee5d86884440c7f7671"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3e64b0cc0439b12df2fa678eae89a1c56a529fd067a9115f7827f1fffd22b32"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "globset"
version = "0.4.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52dfc19153a48bde0cbd630453615c8151bce3a5adfac7a0aebfbf0a1e1f57e3"
dependencies = [
 "aho-corasick",
 "bstr",
 "log",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "ignore"
version = "0.4.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3d782a365a015e0f5c04902246139249abf769125006fbe7649e2ee88169b4a"
dependencies = [
 "crossbeam-deque",
 "globset",
 "log",
 "memchr",
 "regex-automata",
 "same-file",
 "walkdir",
 "winapi-util",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "once_cell_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"

[[package]]
name = "onesource"
version = "0.0.0"
dependencies = [
 "clap",
 "globset",
 "ignore",
]

[[package]]
name = "proc-macro2"
version = "1.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fd00f0bb2e90d81d1044c2b32617f68fcb9fa3bb7640c23e9c748e53fb30934"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.43"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc74d9a594b72ae6656596548f56f667211f8a97b3d4c3d467150794690dc40a"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "regex-automata"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5276caf25ac86c8d810222b3dbb938e512c55c6831a10f3e6ed1c93b84041f1c"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2d987857b319362043e95f5353c0535c1f58eec5336fdfcf626430af7def58"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "2.0.114"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4d107df263a3013ef9b1879b0df87d706ff80f65a86ea879bd9c31f9b307c2a"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "winapi-util"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
dependencies = [
 "windows-sys",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

</file>

<file path="Cargo.toml">
[package]
name = "onesource"
version = "0.0.0"
license = "MIT"
description = "Placeholder"
edition = "2021"
[dependencies]
clap = { version = "4.0", features = ["derive"] }
globset = "0.4.18"
ignore = "0.4.25"

</file>

<file path="src\examples\filter.rs">
use globset::{Glob, GlobSet, GlobSetBuilder};
use std::path::Path;

/// 檔案過濾器結構體
pub struct FileFilter {
    // 使用 Option<T> 作為「開關」
    // None: 代表不執行過濾（全選或不排除）
    // Some(GlobSet): 代表啟動匹配引擎
    pub include: Option<GlobSet>,
    pub exclude: Option<GlobSet>,
}

impl FileFilter {
    /// 建立新的過濾器
    pub fn new(include_str: &str, exclude_str: &str) -> Self {
        // 方案 A：手動判定是否需要啟動引擎
        // 如果使用者輸入 "*" 或空，則視為 None (不進行過濾，效能最快)
        let include = if include_str == "*" || include_str.is_empty() {
            None
        } else {
            Self::build_set(include_str)
        };

        // 如果 exclude 為空，則視為 None (不排除任何檔案)
        let exclude = if exclude_str.is_empty() {
            None
        } else {
            Self::build_set(exclude_str)
        };

        Self { include, exclude }
    }

    /// 私有方法：將逗號分隔的字串編譯成 GlobSet
    fn build_set(patterns: &str) -> Option<GlobSet> {
        let mut builder = GlobSetBuilder::new();
        let mut has_pattern = false;

        for pattern in patterns.split(',') {
            let p = pattern.trim();
            if !p.is_empty() {
                // 處理目錄形式：若以 / 結尾，自動轉為該目錄下所有內容 (dir/**)
                let final_p = if p.ends_with('/') {
                    format!("{}**", p)
                } else {
                    p.to_string()
                };

                // 將字串編譯為 Glob 模式並加入 Builder
                if let Ok(glob) = Glob::new(&final_p) {
                    builder.add(glob);
                    has_pattern = true;
                }
            }
        }

        if has_pattern {
            Some(builder.build().expect("GlobSet 編譯失敗"))
        } else {
            None
        }
    }

    /// 核心匹配邏輯
    pub fn is_match(&self, path: &Path) -> bool {
        // 1. 優先處理排除 (Exclude) 邏輯
        // 如果是 Some，就跑匹配；如果是 None，直接跳過這段
        if let Some(ref ex_set) = self.exclude {
            if ex_set.is_match(path) {
                return false; // 匹配到排除模式，剔除
            }
        }

        // 2. 處理包含 (Include) 邏輯
        match &self.include {
            // 如果有設定特定模式（如 *.py），則必須匹配
            Some(inc_set) => inc_set.is_match(path),
            // 如果是 None（代表使用者輸入 *），直接過關，不跑運算
            None => true,
        }
    }
}
</file>

<file path="src\filter_utils.rs">
use globset::{Glob,GlobSet, GlobSetBuilder};
use std::path::Path;
pub struct FileFilter{
    include:Option<GlobSet>,
    exclude:Option<GlobSet>
}
impl FileFilter{
    /// Determines whether a file path should be kept or discarded.
    ///
    /// # Priority Logic (Exclude-First)
    /// 1. **Exclude first**: If the path matches `exclude`, it is DISCARDED immediately.
    /// 2. **Include second**: If not excluded, the path must match `include` to be KEPT.
    /// 3. **Default**: If `include` is `None` (*), all non-excluded paths are KEPT.
    pub fn new(include:&str,exclude:&str)->Self{

        let include = if include == "*"|| include.is_empty(){
            None
        }else{
            Self::build_set(include)
        };
        let exclude = if exclude == "*"|| exclude.is_empty(){
            None
        }else{
            Self::build_set(exclude)
        };
        Self { include, exclude }
    }
    fn build_set(patterns: &str) -> Option<GlobSet> {
        // Use .gitignore logic
        let mut builder = GlobSetBuilder::new();
        let mut has_pattern = false;

        for pattern in patterns.split(",") {
            let p = pattern.trim().replace('\\', "/");
            
            if p.is_empty() { continue; }
            let is_simple_name = !p.contains('/') && !p.contains('*') && !p.contains('.');

            if is_simple_name {
                builder.add(Glob::new(&format!("**/{}", p)).unwrap());
                builder.add(Glob::new(&format!("**/{}/**", p)).unwrap());
            } else {
                let final_p = if p.ends_with('/') {
                    format!("{}**", p) 
                } else {
                    p
                };
                builder.add(Glob::new(&final_p).unwrap());
            }
            has_pattern = true;
        }

        if has_pattern {
            Some(builder.build().expect("GlobSet compile fail"))
        } else {
            None
        }
    }
pub fn is_match(&self, path: &Path) -> bool {
        if let Some(ref ex_set) = self.exclude {
            if ex_set.is_match(path) {
                return false; 
            }
        }

        match &self.include {
            Some(inc_set) => inc_set.is_match(path),
            None => true,
        }
    }
}
</file>

<file path="src\io_utils.rs">
use std::io::Write;

pub struct MultiWriter<'a, W1: Write, W2: Write> {
    pub writer1: &'a mut W1,
    pub writer2: &'a mut W2,
}

impl<'a, W1: Write, W2: Write> Write for MultiWriter<'a, W1, W2> {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        self.writer1.write_all(buf)?;
        self.writer2.write_all(buf)?;
        Ok(buf.len())
    }

    fn flush(&mut self) -> std::io::Result<()> {
        self.writer1.flush()?;
        self.writer2.flush()?;
        Ok(())
    }
}

pub fn tee<'a, W1: Write, W2: Write>(w1: &'a mut W1, w2: &'a mut W2) -> MultiWriter<'a, W1, W2> {
    MultiWriter { writer1: w1, writer2: w2 }
}
</file>

<file path="src\main.rs">
use clap::{Parser};
use std::{fs::File,path::PathBuf};
use ignore::WalkBuilder;
use std::io::{BufWriter,Write};

mod tree_utils;
mod io_utils;
mod filter_utils;

#[derive(Parser,Debug)]
#[command(name = "onesource", author = "lolLeo", version = "1.0")]
struct Args{
    // File setting
    #[arg(default_value = ".",help = "Set location")]//Target path
    path :PathBuf,
    #[arg(short,long,default_value="allCode.txt")]//Output file name
    output_path:PathBuf,
    #[arg(short,long,default_value="*")]
    include:String,
    #[arg(short='x',long,default_value="")]
    exclude:String,
    
    //content setting
    #[arg(long,action = clap::ArgAction::SetTrue,help="Don't use .gitignore")]
    no_ignore:bool,
    
    
    //Tree setting
    #[arg(long,visible_alias="ti")]
    tree_include: Option<String>,
    #[arg(long,visible_alias="tx")]
    tree_exclude: Option<String>,
    #[arg(long,action = clap::ArgAction::SetTrue,help="Don't write tree")]
    no_tree:bool,
    #[arg(long,action = clap::ArgAction::SetTrue,help="Tree don't use .gitignore")]
    tree_no_ignore:bool,
    
}
fn struct_tree<W: Write>(args:&Args,writer: &mut W){
    let final_include = args.tree_include.as_deref().unwrap_or(&args.include);
    let final_exclude = args.tree_exclude.as_deref().unwrap_or(&args.exclude);
    let filter = filter_utils::FileFilter::new(final_include, final_exclude);
    let mut tree_root = tree_utils::Node::new(true);
    
    let walker = WalkBuilder::new(&args.path)
        .standard_filters(!args.tree_no_ignore)
        .build();
    
    for result in walker{
        match result {
            Ok(entry)=>{
                let rel_path = entry.path().strip_prefix(&args.path).unwrap_or(entry.path());
                if !filter.is_match(rel_path){continue;}
                let is_dir = entry.file_type().map(|t| t.is_dir()).unwrap_or(false);
                tree_root.insert_path(rel_path, is_dir);
            }
            Err(error)=>{
                print!("{}",error)
            }
        }
    }
    let root_name = args.path.canonicalize() // 先轉為絕對路徑
        .ok()
        .and_then(|p| p.file_name().map(|s| s.to_string_lossy().to_string()))
        .unwrap_or_else(|| ".".into());
    writeln!(writer,"{}/", root_name).expect("Write root failed");
    tree_root.print("",writer).expect("Error at print tree");
}
fn rw_file(args:&Args,writer:&mut BufWriter<File>){
    let filter = filter_utils::FileFilter::new(&args.include, &args.exclude);
    let walker = WalkBuilder::new(&args.path)
        .standard_filters(!args.no_ignore)
        .build();
    for result in walker{
        match result {
            Ok(entry)=>{
                let rel_path = entry.path().strip_prefix(&args.path).unwrap_or(entry.path());
                if !filter.is_match(rel_path){continue;}
                let is_dir = entry.file_type().map(|t| t.is_dir()).unwrap_or(false);
                if !is_dir{
                    if let Ok(content) = std::fs::read_to_string(entry.path()) {
                        writeln!(writer, "<file path=\"{}\">", rel_path.display()).unwrap();
                        writeln!(writer, "{}", content).unwrap();
                        writeln!(writer, "</file>\n").unwrap();
                        println!("  + {}",rel_path.as_os_str().to_string_lossy())
                    }
                }
            }
            Err(error)=>{
                print!("{}",error)
            }
        }
    }
    writer.flush().expect("last input flust fail");
}
fn main() {
    let args = Args::parse();
    
    debug_log(&args);

    let file = File::create(&args.output_path).expect("Create output file failed");
    let mut writer = BufWriter::new(file);
    if !args.no_tree{
        let mut stdout = std::io::stdout();
        let mut multi_writer = io_utils::tee(&mut writer, &mut stdout);
        struct_tree(&args,&mut multi_writer);
    }
    rw_file(&args,&mut writer);
}

fn debug_log(args:&Args){
    println!("======ARGS======");
    println!("Target path: {:#?}",args);    
    println!("======Others======")    
}

</file>

<file path="src\tree_utils.rs">
use std::collections::BTreeMap;
use std::io::{self,Write};
use std::path::Path;

#[derive(Debug)]
pub struct Node{
    pub children:BTreeMap<String,Node>,
    pub is_dir:bool,
}

impl Node{
    pub fn new(is_dir:bool)->Self{
        Self {
            children: BTreeMap::new(),
            is_dir,
        }
    }
    pub fn insert_path(&mut self,path:&Path,is_dir:bool){
        let mut current = self;
        for component in path.components(){
            let name = component.as_os_str().to_string_lossy().to_string();
            current = current
                .children.entry(name.clone())
                .or_insert_with(|| Node::new( true));
        }
        current.is_dir = is_dir;
    }
    pub fn print<W: Write>(&self, indent: &str, writer: &mut W) -> io::Result<()>{
        let len = self.children.len();
        for (i,(name,child)) in self.children.iter().enumerate(){
            let is_last = i == len - 1;
            let connector = if is_last {"└── "} else {"├── "};
            writeln!(writer, "{}{}{}{}", indent, connector, name,if child.is_dir { "/" } else { "" })?;
            if !child.children.is_empty(){
                let new_indent = format!(
                    "{}{}",
                    indent,
                    if is_last{"    "} else{"│   "}
                );
                child.print(&new_indent, writer)?;
            }
        }
        Ok(())
    }
}
</file>

